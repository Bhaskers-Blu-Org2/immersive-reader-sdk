// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

package com.example.immersivereadersdk

import android.app.Activity
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.webkit.WebView
import android.widget.Button
import android.webkit.WebViewClient
import android.widget.LinearLayout
import android.widget.TextView
import com.google.gson.*
import java.io.IOException
import java.io.*
import java.net.HttpURLConnection
import java.net.HttpURLConnection.HTTP_OK
import java.net.URL
import kotlinx.coroutines.*
import org.json.JSONObject


// Be sure to add a Constants class (Constants.kt)


class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        this.supportActionBar!!.hide()
        setContentView(R.layout.activity_main)
        val immersiveReaderButton = findViewById<Button>(R.id.LaunchImmersiveReaderButton)
        immersiveReaderButton.setOnClickListener { GlobalScope.launch { handleLaunchImmersiveReader() } }
    }

    private suspend fun handleLaunchImmersiveReader() {
        val exampleActivity = this
        val subdomain = Constants.SUBDOMAIN
        val irTitle = findViewById<TextView>(R.id.Title)
        val irText = findViewById<TextView>(R.id.Content)
        val chunk = Chunk(irText.text.toString(), "en", "text/plain")
        val chunks = listOf(chunk)
        val data = Content(irTitle.text.toString(), chunks)
        val options = Options("ImmersiveReader-Exit","en", 0)
        var token: String

        runBlocking{
            val resp = async { getImmersiveReaderTokenAsync() }
            token = resp.await()
            val jsonResp = JSONObject(token)
            loadImmersiveReaderWebView(exampleActivity, jsonResp.getString("access_token"), subdomain, data, options)
        }
    }

    private suspend fun getImmersiveReaderTokenAsync(): String {
        return getToken()
    }

    @Throws(IOException::class)
    fun getToken(): String {
        val clientId = Constants.CLIENT_ID
        val clientSecret = Constants.CLIENT_SECRET
        val tenantId = Constants.TENANT_ID
        val tokenUrl = URL("https://login.windows.net/$tenantId/oauth2/token")
        val form = "grant_type=client_credentials&resource=https://cognitiveservices.azure.com/&client_id=$clientId&client_secret=$clientSecret"

        val connection = tokenUrl.openConnection() as HttpURLConnection
        connection.requestMethod = "POST"
        connection.setRequestProperty("content-type", "application/x-www-form-urlencoded")
        connection.doOutput = true

        val writer = DataOutputStream(connection.outputStream)
        writer.writeBytes(form)
        writer.flush()
        writer.close()

        val responseCode = connection.responseCode

        if (responseCode == HTTP_OK) {
            val readerIn = BufferedReader(InputStreamReader(connection.inputStream))
            var inputLine = readerIn.readLine()
            val response = StringBuffer()

            do {
                response.append(inputLine)
            } while (inputLine.length < 0)
            readerIn.close()

            // Return token
            return response.toString()
        } else {
            val responseError = Error(code = "BadRequest", message = "There was an error getting the token.")
            throw IOException(responseError.toString())
        }
    }

    private lateinit var contextualWebView: WebView

    data class Content(var title: String,
                       var chunks: List<Chunk>)

    data class Chunk(var content: String,
                     var lang: String,
                     var mimeType: String)

    data class Options(var exitCallback: String,
                       var uiLang: String,
                       var timeout: Int)

    data class Error(var code: String,
                     var message: String)

    data class Message(var cogSvcsAccessToken: String?,
                       var cogSvcsSubdomain: String,
                       var resourceName: String?,
                       var request: Content,
                       var launchToPostMessageSentDurationInMs: Int,
                       var options: Options)

    @Throws(IOException::class)
    fun loadImmersiveReaderWebView(
        exampleActivity: Activity,
        token: String?,
        subdomain: String,
        content: Content,
        options: Options) {
        if (token === "") {
            val badArgumentError = Error(code = "BadArgument", message = "Token must not be empty.")
            throw IOException(badArgumentError.toString())
        }
        if (subdomain === "") {
            val badArgumentError = Error(code = "BadArgument", message = "Subdomain must not be empty.")
            throw IOException(badArgumentError.toString())
        }
        if (content.chunks.isEmpty()) {
            val badArgumentError = Error(code = "BadArgument", message = "Chunks must not be empty.")
            throw IOException(badArgumentError.toString())
        }

        // Create the message variable
        val messageData = Message(token, subdomain, null, content, 0, options)

        // Deserialize message data class to JSON
        val gson = Gson()
        val message = gson.toJson(messageData)

        GlobalScope.launch {
            withContext(Dispatchers.Main) {
                contextualWebView = WebView(exampleActivity)
                val parentLayout = findViewById<LinearLayout>(R.id.linearLayout)
                val contextualWebViewSettings = contextualWebView.settings

                contextualWebViewSettings.allowContentAccess = true
                contextualWebViewSettings.builtInZoomControls = true
                contextualWebViewSettings.javaScriptEnabled = true
                contextualWebViewSettings.loadsImagesAutomatically = true
                contextualWebViewSettings.loadWithOverviewMode = true
                contextualWebViewSettings.useWideViewPort = true
                contextualWebViewSettings.userAgentString = "Android"
                contextualWebViewSettings.domStorageEnabled = true

                contextualWebViewSettings.setAppCacheEnabled(false)
                contextualWebViewSettings.setSupportZoom(true)
                contextualWebView.setInitialScale(1)

                val contextualWebViewLayout = LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT)
                parentLayout.addView(contextualWebView, 0, contextualWebViewLayout)

                // This is required to launch the WebView *inside* the host application.
                contextualWebView.webViewClient = object : WebViewClient() {
                    override fun shouldOverrideUrlLoading(view: WebView, url: String): Boolean {
                        view.loadUrl(url)
                        return true
                    }

                    // Send message JSON object to Immersive Reader html
                    override fun onPageFinished(view: WebView, url: String) {
                        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.KITKAT) {
                            view.evaluateJavascript("handleLaunchImmersiveReader($message)", null)
                        } else {
                            view.loadUrl("javascript:handleLaunchImmersiveReader($message)")
                        }

                        // Sets the visibility of the WebView after the function has been called.
                        view.visibility = WebView.VISIBLE
                    }
                }

                val jsInterface = WebAppInterface(exampleActivity, parentLayout, contextualWebView)
                contextualWebView.addJavascriptInterface(jsInterface, "Android")
                contextualWebView.loadUrl("file:///android_asset/immersiveReader.html")
            }
        }
    }
}
